# 模块代码编写基础

- 模块的创建
  - 普通python脚本, 以`.py`结尾; 模块名的命名遵循变量名的命名规则
- 模块的使用
  - import语句
    - `import sys`
  - from语句
    - `from sys import path`
  - from *
    - `from sys import *`
    - 引入模块中的所有方法和属性(理论上可能引起命名空间的冲突)
- 导入只发生一次
  - 第一次导入时, python将执行转码=>编译=>运行三个步骤, 当再次被导入时, 会跳过此三步骤
  - 所有要使用修改过的模块, 可使用`from imp import reload`
- import 和 from赋值语句
  - import和from类似于def都是隐性的赋值语句
  - `import module as m`或`from module import method as m`
- from语句潜在的陷阱
  - from语句会让变量(属性)位置模糊, 以至于不确定该变量属于哪里
  - 命名空间混乱, 覆盖之前的变量
  - 如果两个模块中有相同的方法, 可以使用import语句, 更清晰的知道用的是哪个模块的方法
- 模块命名空间
  - 模块是变量名的封装
  - 文件生成命名空间
    - 模块语句会在首次导入时执行
    - 顶层的赋值语句会创建模块属性
    - 模块的命名空间能通过属性`__dict__`或`dir(M)`来获取
    - 模块是一个独立的作用域(本地变量就是全局变量)
- 属性名的点号运算
  - 简单变量
  - 点号运算
    - x.y: 在当前范围,内寻找对象x, 再搜索对象x中的属性y
  - 多层点号运算
    - x.y.z: 寻找对象x中的变量名y, 再从对象y中寻找z
  - 通用性
    - 点号运算可用于具有属性的对象: 模块, 类, c扩展
- 导入和作用域
- 命名空间的嵌套
- 重载模块
- reload基础
  - reload会在模块当前命名空间内执行模块文件的新代码
  - 文件中顶层赋值语句会使变量名换成新值
  - reload重载会影响所有使用import读取了模块的客户端
  - 重载只会对以后使用from的客户端造成影响
- reload实例
- 为什么要在意reload
  - 不仅仅在交互模式下重载重要
  - 在大型程序中, 相较于重启整个程序, 动态的重载部分模块更为高效